\addcontentsline{toc}{part}{Part I}
\chapter{\label{cha:intro}Introduction}

Compilers are ubiquitous and pivotal components
at the core of innumerable software systems and programming language ecosystems.
As a consequence, the ramifications that arise from flawed
compiler implementations can be both far-reaching and severe.
The outstanding complexity and feature richness of compilers has created
several formidable challenges, the scope of which is perhaps best exemplified
by \citet{hoare2003verifying}
declaring the task of building a provably correct compiler to be a 
\textit{Grand Challenge} in computing research.
Researchers and practitioners have invested tremendous amounts of resources
into compiler research in recent decades, attempting to improve
performance, quality, and reliability. 
Such efforts are especially beneficial for newer software systems,
that require robust compilation pipelines to establish themselves
as worthy alternatives to mature standards.


\section{Compiler Testing}

Because of their cornerstone role in many critical applications,
compilers are often subject to thorough quality assurance processes.
Many research directions incorporate testing as a means
of assessing and improving the correctness of compilers.
Empirical evidence supports the benefits of such approaches,
with \citet{sun2016toward} and \citet{holler2012fuzzing} highlighting
the existence of bugs in widely used C compilers and JavaScript engines, respectively. 
These findings stand out because of the maturity of the
software ecosystems that pivot around these technologies, showcasing
the necessity of effective testing methods.

One approach to testing compilers is to assemble manually-written test suites.
This strategy has several advantages, including the possibility to individually
target specific components of the compiler and the developer's ability to
reason about the tests' semantics and expected outputs.
However, the labor-intensive nature of this process and 
the imposing complexity of compiler code bases have
led to automated test case generation methods superseding their 
manual counterparts \citep{chen2020survey, zhao2009automated}.
Though compelling and time-effective, automated test case
generation strategies concurrently give rise to an arduous set of challenges.
The infinite number of correct possible programs, the syntactic dependencies between code snippets,
the diversity required to exercise a broad range of compiler features,
and the many semantic nuances attributed to each programming language all constitute
obstacles that an effective generative algorithm must address.

Fuzzing, or random testing, lends itself naturally to this task thanks to its
ability to generate code snippets that trigger diverse behavior within the compiler.
Because of this, researchers have proposed a myriad of language-specific approaches, 
fixated around two overarching paradigms.
Algorithms that generate standalone code such as those proposed by  
\citet{yang2011finding, holler2012fuzzing, veggalam2016ifuzzer}, and \citet{havrikov2019systematically}
have the ability to generate novel test programs, which in turn may contain
seldom encountered constructs and relations.
By contrast, mutation-centric approaches such as those put forward by 
\citet{le2014compiler, le2015finding, sun2016finding}, and \citet{stepanov2021type}
rely on an input or seed program, that serves as a basis for subsequent transformations.
While the former approach may be able to explore more of the
space of feasible input programs, the latter effectively leverages
large corpora that become available as programming language
ecosystems mature.

\section{The Kotlin Programming Language}

Kotlin \cite{kotlinlang} is a relatively new programming language whose development
initiative is led by JetBrains.
Initially designed as a Java alternative, the Kotlin
ecosystem has steadily grown and currently envelops
a broad range of use-cases, including server-side development,
web front-end interfaces, and mobile applications. 
Kotlin showcases several compelling features, including expressiveness,
safety, and interoperability, which have played a key role in Google embracing
a "Kotlin-first" approach in its popular Android mobile operating system \cite{kotlinfirst}.

The number of research initiatives investigating Kotlin's impact 
in the software development process has risen in tandem with its adoption.
Several studies have analyzed both Kotlin's influence
on the quality of code bases, as well as developers' perception
of Kotlin in comparison to their previous experience.
\citet{flauzino2018you}  and \citet{gois2019empirical} independently
found that code bases which at least partially employ Kotlin tend to
exhibit fewer code smells than their Java counterparts. 
\citet{ardito2020effectiveness} suggest that transitioning projects
from Java to Kotlin can meaningfully increase code conciseness.
\citet{chauhan2021performance} provide empirical evidence indicating
that Kotlin's coroutine implementation vastly outperforms
Java's thread-centric concurrency framework in terms of speed.
\citet{oliveira2020adoption} study Android practitioners' opinions regarding
Kotlin adoption and reveal that developers find Kotlin easy
to adopt and understand. 
Their study also showcases that developers value Kotlin's
null-safety guarantees, as well as its interoperability with Java.

Despite the sharp rise in Kotlin's popularity and an increasing
number of systems relying on its ecosystem, the study by \citet{stepanov2021type}
is the only one to propose a tailored algorithm for automatically 
testing the Kotlin compiler.
Their work heavily relies on manually written test suites to 
provide seeds for an enumeration-based fuzzer aimed at detecting compilation
errors between different compiler implementations. 
Currently, no tool that is capable of generating entirely novel, semantically 
meaningful, and diverse test programs for the Kotlin compiler exists.
Creating such an algorithm would not only aid the quality assurance process
of the Kotlin compiler, but also provide valuable insight relating to
which language features require additional work and which
fuzzing strategies are best suited for revealing compiler bugs.

\section{\label{sec:aim}Research Aim and Scope}

This thesis seeks to advance the current understanding of the
effectiveness of test program-based fuzzing as a means of automated compiler testing.
To narrow the scope of this goal, we identify and acknowledge several
key limitations.
First, this thesis only concerns itself with empirical analyses regarding
the Kotlin compiler. 
Though the prototype implementation may well be 
extended to target other systems, we use a single benchmark to ensure feasibility.
Second, this study investigates the ability of the proposed fuzzing
techniques to find bugs in the targeted compiler, and does not emphasize
the practical or commercial implications of the uncovered bugs.
Further, research concerning other widely studied defect-centric 
practices such as bug localization, program minimization, and bug deduplication
are outside the scope of this study.
Within these constraints, we seek to achieve the following research aim:

\begin{quote}
\centering 
\emph{The aim of this research is to gain insight into how 
effective test program-based fuzzing is at uncovering bugs in the
Kotlin compiler.}
\end{quote}

To address this aim, we implement a grammar-aided fuzzing tool
that generates Kotlin code snippets. 
The generated pieces of code serve as input to the compiler,
whose behavior is in turn assessed through differential testing.
We divide the overarching research aim into several, more granular
research questions.
We first consider the effectiveness of our approach in comparison
to existing mutation-based fuzzing algorithms, leading to
the following research question:

\begin{quote}
\centering 
\emph{\textbf{RQ1:} How effective is test program-based
fuzzing compared to mutation-based fuzzing
at uncovering bugs in the Kotlin compiler?}
\end{quote}

To better understand the reasons behind the relative performance
of our approach, we seek to isolate its most crucial components.
Such insight establishes a baseline for future research to expand upon
by providing insight into which fuzzing techniques result in better performance.
We encapsulate this goal into the following research question:

\begin{quote}
\centering 
\emph{\textbf{RQ2:} How effective are different test program-based
fuzzing heuristics at uncovering bugs in the Kotlin compiler?}
\end{quote}

A vital point to consider when designing a fuzzing algorithm is
its potential to adapt to the goals of its users. \citet{amalfitano2015exploiting}
show that random testing approaches eventually reach a
saturation point, where novel input is exceedingly unlikely to trigger
detecting new faults. 
To combat this, practitioners can either design new tools, adapt existing
ones, or intertwine approaches.
While flexible design can help mitigate this shortcoming, studying the 
bug finding capability of a combination of tools enables
the exploration of a broader range of the input space.
To explore this potential, we study the effectiveness of 
integrating of test program- and mutation-based fuzzing.
To this end, we propose the following research question:

\begin{quote}
\centering 
\emph{\textbf{RQ3:} How effective is the combination of 
test program- and mutation-based fuzzing techniques at uncovering
bugs in the Kotlin compiler?}
\end{quote}

\section{Contributions and Significance}

This thesis makes both theoretical and practical advances,
relevant to both the field of compiler testing and to the 
Kotlin community. To summarize, we expect this
study to result in the following contributions:

\begin{enumerate}
	\item At least one novel grammar-aided, Kotlin-specific compiler fuzzing algorithm.
	\item A modular and configurable prototype implementing the novel algorithm.
	\item Empirical anlysis comparing the bug finding capabilities of test program- and mutation-based fuzzers for Kotlin, as well as the combination of the two
	\item A replication package containing open-source artifacts, able to reproduce the studies
\end{enumerate}

From a theoretical perspective, we expect our contributions
to deepen the insight into the applicability and effectiveness
of test program-based fuzzing and its adjacent heuristics, as a 
means of compiler testing. 
The significance of this knowledge is tied to the continued
interest in establishing reliable quality assurance measures for compilers.
On a practical level, we expect the resulting
prototype implementation to become a useful tool for improving the 
reliability and quality of the Kotlin compiler.
Compiler engineers can leverage such a tool as an additional
step in a continuous integration pipeline, or choose to employ it
when developing novel features in future versions of the language.

\section{Overview of the Study}

This thesis consists of eight additional chapters situated in three main parts.
Part I consists of Chapters \ref{cha:background} and \ref{cha:related}, and
provides an overview of the relevant body of knowledge and literature.
Chapter \ref{cha:background} introduces the theoretical background
that constitutes the foundation of this study.
Chapter \ref{cha:related} discusses related work and positions this
thesis within the current research landscape.

Part II encompasses Chapters \ref{cha:algorithm}, \ref{cha:tool}, \ref{cha:study}, and \ref{cha:results}
and details the main contributions of this thesis. 
Chapter \ref{cha:algorithm} describes the conceptual outline of
the fuzzing procedure and the rationale behind its
underpinning design choices.
Chapter \ref{cha:tool} delineates the prototypical implementation
of our tool and highlights its practical applications.
Chapter \ref{cha:study} outlines the design of the empirical
study carried out to evaluate the performance of our tool.
Chapter \ref{cha:results} analyzes the results of the empirical study
and ties them to the main research questions.

Part III includes Chapters \ref{cha:discussion} and \ref{cha:conc} 
and reflects upon the outcomes of this study.
Chapter \ref{cha:discussion} fixates on discussing the main 
findings of this research within a broader landscape
and considers their practical ramifications with respect to the Kotlin compiler.
Finally, Chapter \ref{cha:conc} reflects upon this
thesis and makes concluding recommendations for future research.

